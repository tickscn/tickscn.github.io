<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS on ticks blog</title>
    <link>https://tickscn.github.io/tags/cs/</link>
    <description>Recent content in CS on ticks blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 25 Dec 2019 15:47:00 +0800</lastBuildDate><atom:link href="https://tickscn.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>多线程问题习题</title>
      <link>https://tickscn.github.io/post/osc_chapter4_answer/</link>
      <pubDate>Wed, 25 Dec 2019 15:47:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/osc_chapter4_answer/</guid>
      <description>4.15 创建多线程程序验证 3.13 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59</description>
    </item>
    
    <item>
      <title>汇编基本运算</title>
      <link>https://tickscn.github.io/post/asm-num-arithmetic/</link>
      <pubDate>Sat, 14 Dec 2019 20:04:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/asm-num-arithmetic/</guid>
      <description>整型运算 加 (addition) add 指令 add 指令用来加两个整型 1 add source, destination source 可以是寄存器, 内存, 立即数 destination 可以是寄存器, 内存 但是 source 和 destination 不可以同时是内存 add 后面应该加上后缀来</description>
    </item>
    
    <item>
      <title>多线程问题</title>
      <link>https://tickscn.github.io/post/multhread-issues/</link>
      <pubDate>Mon, 09 Dec 2019 20:45:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/multhread-issues/</guid>
      <description>fork() and exec() 某个线程调用 fork(), 新进程复制所有线程还是单一线程? 有的 UNIX 系统有两种形式的 fork() exec() 指定的程序会取代所有线程 信号处理 UNIX 信号(signal) 用于通知</description>
    </item>
    
    <item>
      <title>汇编数字</title>
      <link>https://tickscn.github.io/post/asm-number/</link>
      <pubDate>Mon, 09 Dec 2019 19:55:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/asm-number/</guid>
      <description>数字类型(numeric data type) 基本数字类型 无符号整型(unsigned integer) 有符号整型(signed integer) BCD 压缩 BCD 单精度浮点数 双精度浮点数 扩展精度浮点</description>
    </item>
    
    <item>
      <title>汇编控制执行顺序</title>
      <link>https://tickscn.github.io/post/asm-flow-control/</link>
      <pubDate>Sun, 08 Dec 2019 18:00:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/asm-flow-control/</guid>
      <description>程序不总是按顺序从头到尾执行, 有时需要分支或者循环. 指令指针(The Instruction Pointer) 指令指针决定下一个要执行的指令. 此时 EIP(x86_64 是 RIP)不断增加 不能在程序中</description>
    </item>
    
    <item>
      <title>rust(2)-data-type</title>
      <link>https://tickscn.github.io/post/rust-2-data-type/</link>
      <pubDate>Thu, 05 Dec 2019 18:25:53 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/rust-2-data-type/</guid>
      <description>数据类型 数据类型有两个子集. 标量(scalar) 混合(compound) rust 是静态类型语言, 编译期时就需要知道数据类型. 当有多种可能时, rus</description>
    </item>
    
    <item>
      <title>stack</title>
      <link>https://tickscn.github.io/post/stack/</link>
      <pubDate>Wed, 04 Dec 2019 18:28:03 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/stack/</guid>
      <description>堆栈(The Stack) 堆栈的工作方式 堆栈是一段特殊的内存空间. 它特殊在数据的插入和删除数据的方式. 普通的数据段(data section)数据顺序存储</description>
    </item>
    
    <item>
      <title>rust(1)</title>
      <link>https://tickscn.github.io/post/rust-1/</link>
      <pubDate>Wed, 04 Dec 2019 16:21:59 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/rust-1/</guid>
      <description>一般概念 需要了解 变量 基本类型 函数 注释 关键字: rust 像其它语言一样有着保留的关键字, 关键字不能用作变量名和函数名等其它地方 变量(Variables</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://tickscn.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 04 Dec 2019 14:43:49 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>线程是CPU使用的基本单元 线程ID 程序计数器 寄存器组 堆栈 与进程不同的是线程共用数据和代码 多线程的优点 响应性: 部分阻塞时仍能运行 资源共享: 与进</description>
    </item>
    
    <item>
      <title>move-data</title>
      <link>https://tickscn.github.io/post/move-data/</link>
      <pubDate>Sun, 01 Dec 2019 16:18:37 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/move-data/</guid>
      <description>数据定义 data section 数据段(data section)是最通常的定义数据的地方. 定义了数据内存中的存储位置, 可以在指令中引用, 修改 由 .data 伪指令声明. 该 section</description>
    </item>
    
    <item>
      <title>simple-assembly-program</title>
      <link>https://tickscn.github.io/post/simple-assembly-program/</link>
      <pubDate>Fri, 29 Nov 2019 19:43:09 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/simple-assembly-program/</guid>
      <description>一个汇编语言的模板 1 2 3 4 5 6 7 8 .section .data &amp;lt; initialized data &amp;gt; .section .bss &amp;lt; uninitialized data &amp;gt; .section .text .globl _start _start: &amp;lt; instruction code &amp;gt; 一个简单的汇编程序 CPUID 指令 根据EAX寄存器的值, CPUID 指令将信息存入 EBX,</description>
    </item>
    
    <item>
      <title>指令管理</title>
      <link>https://tickscn.github.io/post/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 28 Nov 2019 20:37:58 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%90%86/</guid>
      <description>CPU从内存读取指令(instruction)和数据(data). 为了区分指令和数腒, 分别使用指令指针(instruction pointer), 数据指针(d</description>
    </item>
    
    <item>
      <title>simple_unix_shell</title>
      <link>https://tickscn.github.io/post/simple-unix-shell/</link>
      <pubDate>Wed, 27 Nov 2019 16:18:40 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/simple-unix-shell/</guid>
      <description>UNIX Shell 提供命令提示符. 如 ticks&amp;gt; 1 ticks&amp;gt; cat a.txt 读取命令, 创建子进程 命令最后加 &amp;ldquo;&amp;amp;&amp;rdquo; 符号, shell 与 子程序并发执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</description>
    </item>
    
    <item>
      <title>单源最短路径</title>
      <link>https://tickscn.github.io/post/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 27 Nov 2019 14:59:46 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>带权有向图 V = (G, E)权重函数了$\omega: E\rightarrow \mathbf{R}$. 图中路径的权重是组成路径的边权重之和. 最短路径问题是求权重最小路径的问题 最短路径的变体 单源</description>
    </item>
    
    <item>
      <title>OSC3 习题</title>
      <link>https://tickscn.github.io/post/osc3-%E4%B9%A0%E9%A2%98/</link>
      <pubDate>Tue, 26 Nov 2019 15:19:39 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/osc3-%E4%B9%A0%E9%A2%98/</guid>
      <description>习题 以下程序创建了多少进程 1 2 3 4 5 6 7 8 9 10 11 12 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; int main() { int i; for (i = 0; i &amp;lt; 4; i++) fork(); return 0; } $2^4 = 16$ 假设父进程pid 2600, 子进程pid 2603, 下程序输出 1</description>
    </item>
    
    <item>
      <title>最小生成树</title>
      <link>https://tickscn.github.io/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Tue, 26 Nov 2019 13:52:34 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>一个边通无向图 G = (V, E), 为每一条边(u, v)$\in$ E, 赋予权重 w(u, v), 那么 G 的一个无环子集 , 使得 T 连通所有结点且权重最小. 该子集 T 被称作 最小生成树. 求取 T 的</description>
    </item>
    
    <item>
      <title>强连通分量</title>
      <link>https://tickscn.github.io/post/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</link>
      <pubDate>Mon, 25 Nov 2019 15:38:47 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</guid>
      <description>强连通分量 有向图 G = (V, E) 的强连通分量是指一个最大点集C$subseteq$U, $\forall u,v \in C$, u,v 可互相到达 1 2 3 4 5 STRONGLY-CONNECTED-COMPONENTS(G) call DFS(G) to compute u.f compute G&amp;#39;s transpose GT call DFS(GT), each loop of DFS,</description>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://tickscn.github.io/post/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 23 Nov 2019 18:38:02 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>对有向无环图G = (V, E)来说, 拓扑排序是G的一种线性排序. 该排序满足, 存在弧(u, v), u在v前. 1 2 3 4 5 6 TOPOLOGICAL-SORT(G) { 用 DFS 计算结束时间v.f 当 v结束时</description>
    </item>
    
    <item>
      <title>64位 x86_64</title>
      <link>https://tickscn.github.io/post/64-bit-x86/</link>
      <pubDate>Sat, 23 Nov 2019 14:52:38 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/64-bit-x86/</guid>
      <description>x86_64 指令集是x86指令集的64位扩展 向后兼容x86指令集 地址长度为64位, 虚拟地址空间为 16EiB ($2^64$). 根据芯片实现, 只使用低48位(256TiB) 可以使</description>
    </item>
    
    <item>
      <title>32位 x86</title>
      <link>https://tickscn.github.io/post/32%E4%BD%8Dx86/</link>
      <pubDate>Fri, 22 Nov 2019 15:48:30 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/32%E4%BD%8Dx86/</guid>
      <description>操作模式 保护模式(Protected Mode): 原生状状, 所有的指令和特性都是可用的. 程序会被分配独立内存(段). 处理器禁止程序使用自身段外的内存 虚拟</description>
    </item>
    
    <item>
      <title>x86微机设计</title>
      <link>https://tickscn.github.io/post/x86%E5%BE%AE%E6%9C%BA%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 21 Nov 2019 20:03:10 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/x86%E5%BE%AE%E6%9C%BA%E8%AE%BE%E8%AE%A1/</guid>
      <description>基本微机设计 CPU 是进行算术和逻辑操作的部件, 包含了有限数量的存储位置——寄存器(register), 高频时钟, 控制单元和逻辑单元 时钟(cloc</description>
    </item>
    
    <item>
      <title>汇编语言1.7.2</title>
      <link>https://tickscn.github.io/post/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-7-2/</link>
      <pubDate>Thu, 21 Nov 2019 16:25:22 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-7-2/</guid>
      <description>算法基础 编写一个函数来接收一个16位二进制整数字符串. 函数返回为该字符串的整数值 编写一个函数来接收一个32位二进制整数字符串. 函数返回为该字</description>
    </item>
    
    <item>
      <title>breadth-first-search and depth-first-search</title>
      <link>https://tickscn.github.io/post/breadth-first-search/</link>
      <pubDate>Thu, 21 Nov 2019 14:00:25 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/breadth-first-search/</guid>
      <description>广度优先搜索 给定图 G=(V,E) 的一个可以识别的源结点 s, 计算从s可到达的结点的距离, 同时生成一个广度优先搜索树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 BFS(G,</description>
    </item>
    
    <item>
      <title>process</title>
      <link>https://tickscn.github.io/post/process/</link>
      <pubDate>Wed, 20 Nov 2019 16:36:38 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/process/</guid>
      <description>进程(process) 文本段(test section)或叫代码段(code section) 程序计数器(program counter) 栈(stack) 堆(heap) 进程状</description>
    </item>
    
    <item>
      <title>Linux 内核模块</title>
      <link>https://tickscn.github.io/post/linux-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Tue, 19 Nov 2019 16:47:29 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/linux-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</guid>
      <description>操作系统概念第二章编程项目&amp;ndash;Linux 内核模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &amp;lt;linux/init.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt; /* This function is called when the module is loaded. */ int</description>
    </item>
    
    <item>
      <title>可合并堆操作</title>
      <link>https://tickscn.github.io/post/algo19-2/</link>
      <pubDate>Tue, 19 Nov 2019 14:22:42 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/algo19-2/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct FbHeapNode{ int key; FbHeapNode *left; FbHeapNode *right; FbHeapNode *parent; FbHeapNode *child; size_t degree; //&amp;lt; 孩子链表结点数目 bool mark; //&amp;lt; 成为孩子结点后是否失去过</description>
    </item>
    
    <item>
      <title>操作系统的实现</title>
      <link>https://tickscn.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 18 Nov 2019 16:34:04 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>设计与实现 设计目标分为两个基本大类 用户目标(user goal) 系统目标(system goal) 机制与策略 策略(policy) 做什么 机制(mechanism)</description>
    </item>
    
    <item>
      <title>系统调用</title>
      <link>https://tickscn.github.io/post/systemcall/</link>
      <pubDate>Sun, 17 Nov 2019 18:40:06 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/systemcall/</guid>
      <description>系统调用(system call) 提供操作系统服务接口。应用程序开发人员根据应用编程接口(Application Programming Interface, API) 来设计程序。有三组常用API Windows API</description>
    </item>
    
    <item>
      <title>斐波那契堆</title>
      <link>https://tickscn.github.io/post/algo19/</link>
      <pubDate>Sun, 17 Nov 2019 14:25:44 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/algo19/</guid>
      <description>可合并堆(mergeable heap). 支持以下操作(默认的是最小堆. 可以有对称的最大堆) MAKE-HEAP() 创建一个新的不含任何元素的堆 INSERT(H, x) 将以填入关键字的元素x插入</description>
    </item>
    
  </channel>
</rss>
