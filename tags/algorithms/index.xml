<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on ticks blog</title>
    <link>https://tickscn.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on ticks blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 23 May 2020 16:10:00 +0800</lastBuildDate><atom:link href="https://tickscn.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法</title>
      <link>https://tickscn.github.io/post/cpp_algorithms/</link>
      <pubDate>Sat, 23 May 2020 16:10:00 +0800</pubDate>
      
      <guid>https://tickscn.github.io/post/cpp_algorithms/</guid>
      <description>概论 大部分算法定义在头文件 algorithm 中, numeric 中定义了常用数学算法 通常算法不是直接作用在容器上, 而是作用在两个迭代器之间的容器. 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>单源最短路径</title>
      <link>https://tickscn.github.io/post/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 27 Nov 2019 14:59:46 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>带权有向图 V = (G, E)权重函数了$\omega: E\rightarrow \mathbf{R}$. 图中路径的权重是组成路径的边权重之和. 最短路径问题是求权重最小路径的问题 最短路径的变体 单源</description>
    </item>
    
    <item>
      <title>最小生成树</title>
      <link>https://tickscn.github.io/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Tue, 26 Nov 2019 13:52:34 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>一个边通无向图 G = (V, E), 为每一条边(u, v)$\in$ E, 赋予权重 w(u, v), 那么 G 的一个无环子集 , 使得 T 连通所有结点且权重最小. 该子集 T 被称作 最小生成树. 求取 T 的</description>
    </item>
    
    <item>
      <title>强连通分量</title>
      <link>https://tickscn.github.io/post/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</link>
      <pubDate>Mon, 25 Nov 2019 15:38:47 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</guid>
      <description>强连通分量 有向图 G = (V, E) 的强连通分量是指一个最大点集C$subseteq$U, $\forall u,v \in C$, u,v 可互相到达 1 2 3 4 5 STRONGLY-CONNECTED-COMPONENTS(G) call DFS(G) to compute u.f compute G&amp;#39;s transpose GT call DFS(GT), each loop of DFS,</description>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://tickscn.github.io/post/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 23 Nov 2019 18:38:02 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>对有向无环图G = (V, E)来说, 拓扑排序是G的一种线性排序. 该排序满足, 存在弧(u, v), u在v前. 1 2 3 4 5 6 TOPOLOGICAL-SORT(G) { 用 DFS 计算结束时间v.f 当 v结束时</description>
    </item>
    
    <item>
      <title>breadth-first-search and depth-first-search</title>
      <link>https://tickscn.github.io/post/breadth-first-search/</link>
      <pubDate>Thu, 21 Nov 2019 14:00:25 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/breadth-first-search/</guid>
      <description>广度优先搜索 给定图 G=(V,E) 的一个可以识别的源结点 s, 计算从s可到达的结点的距离, 同时生成一个广度优先搜索树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 BFS(G,</description>
    </item>
    
    <item>
      <title>可合并堆操作</title>
      <link>https://tickscn.github.io/post/algo19-2/</link>
      <pubDate>Tue, 19 Nov 2019 14:22:42 +0000</pubDate>
      
      <guid>https://tickscn.github.io/post/algo19-2/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct FbHeapNode{ int key; FbHeapNode *left; FbHeapNode *right; FbHeapNode *parent; FbHeapNode *child; size_t degree; //&amp;lt; 孩子链表结点数目 bool mark; //&amp;lt; 成为孩子结点后是否失去过</description>
    </item>
    
  </channel>
</rss>
